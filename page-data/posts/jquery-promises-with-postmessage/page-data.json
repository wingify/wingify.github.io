{"componentChunkName":"component---src-templates-post-js","path":"/posts/jquery-promises-with-postmessage/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"http://visualwebsiteoptimizer.com/\">Visual Website Optimizer</a>'s editor component loads a website for editing using a\nproxy tunnel. It put a big restriction on what kind of websites could be loaded\nin it. Websites behind a firewall, the ones on a local network, or behind HTTP\nauthentication could not be loaded using the tunnel. Other than those, even if\nthe website did load in the editor, chances were that it could break on the\nfrontend due to issues with JavaScript or AJAX communication.</p>\n<p>You'd ask: why is there a proxy in the first place? Because, if a page contains\nan iframe on another domain, it cannot access its properties or functions. It is\na security feature that browser vendors offer users to protect their privacy.</p>\n<h2 id=\"the-problem\" style=\"position:relative;\"><a href=\"#the-problem\" aria-label=\"the problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Problem</h2>\n<p>So, our task at the frontend recently was to eliminate this troublesome\nmiddleman and find a solution for cross-domain iframe communication. We knew\nwhat the answer was: the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window.postMessage\">PostMessage API</a>.\nProvided a customer had VWO tracking\ncode integrated on their website, we could load the iframe directly without a\nproxy and communicate with it using this API. The bigger question, however, was\nhow to do it. The Editor had a lot of parent-child communication going under the\nhood for every task the user performed.  When attempting to use PostMessage for\nthis communication, we were faced with a couple of issues:â€¨</p>\n<ol>\n<li>Our legacy code had direct communication between the parent frame and the\nchild frame at all places, i.e. the objects and functions in the child were\naccessed synchronously. PostMessage API, on the other hand, is completely\nasynchronous, and implementing such an API on the existing codebase would almost\nmean rethinking the entire logic and program flow all over again.  We could\nforesee this asynchronous transition become a cause of a lot of race conditions\nwithin the Editor.</li>\n<li>Often, after sending a message to the other frame, we wanted to hear back a\nreply, for which we needed a decent two-way communication. A kind that would\nkeep track of the sender and the receiver and could be identified across iframes\nusing a unique identifier (to tie up the requests and responses).</li>\n<li>Since PostMessage uses string messages for communication (or <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/DOM/The_structured_clone_algorithm\">structurally\ncloneable</a>\nobjects in the recent browsers), it put a big limit on what kind of\ndata we could send during this communication. Directly accessing DOM nodes and\nsending around certain cyclic objects was no longer possible.</li>\n</ol>\n<p>For instance, when you select an element in the child frame, it creates a new\n<code class=\"language-text\">VWO.Element</code> instance in the parent frame and asks it to open a context menu. The\ncode looked something like this:</p>\n<p>{% highlight js %}\n$(elementSelectorPath).click(function() {\nvar element = parent.VWO.Element.create(elementSelectorPath);\nparent.VWO.ContextMenu.showForElement(element);\n});\n{% endhighlight %}</p>\n<p>While, it might seem like a trivial problem to solve on the cover, deep\nunderneath, we were faced with a race condition. The <code class=\"language-text\">Element.create</code> method\nasked the child frame to add a class to that element, and the\n<code class=\"language-text\">ContextMenu.showForElement</code> expected the class to have been applied by the time\nit was executed.</p>\n<h2 id=\"the-solution\" style=\"position:relative;\"><a href=\"#the-solution\" aria-label=\"the solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Solution</h2>\n<p>We concluded that refactoring the code to adapt to the asynchrony would be one\nhell of a task and we had to find another way. We decided to write a wrapper\naround the PostMessage API to solve the above three problems. We called it\n<code class=\"language-text\">please.js</code>. We are currently giving it some finishing touches before we push it\nout to the community. Here's how we did it:</p>\n<ul>\n<li>We decided to build this library on top of jQuery Deferred API. While\ndeferred objects and promises don't exactly eliminate the asynchrony, they\nsomehow bridge the gap between the two, making asynchronous code feel more\nlinear and flattened. So, using that base, any piece of code that expected code\nprior to it to have been executed fully, could now be made possible without\ngiving a lot of thought. In the above example, the transition to <code class=\"language-text\">please.js</code>\nlooked like this:</li>\n</ul>\n<p>{% highlight js %}\n$(elementSelectorPath).click(function() {\nplease(parent)\n.call('VWO.Element.create', elementSelectorPath)\n.then(function (element) {\nplease(parent)\n.call('VWO.ContextMenu.showForElement', element);\n});\n});\n{% endhighlight %}</p>\n<p>Although this seems hackish at the first glance, it was a way to rapidly\niterate over synchronous code and convert it to use promises and callbacks\nwithout giving much thought on the logic.</p>\n<ul>\n<li>To establish a good two-way communication, we thought of thinking of each\ncommunication as a pair of messages: a request and a response. Under the hood,\nwe identified each message using a timestamp it was initiated on, and created a\nrequest object with that identifier. We then send the request to the other\nframe, whilst storing it in the current frame in a hashmap. The other frame\nwould then receive the request, perform an appropriate action and send back a\nresponse. After a response is received, the request would be deleted from the\nhashmap. To make things easier for us, we created a set of functions to make\ncertain frequent tasks easier. For instance, getting / setting a property and\ncalling a function were the most common tasks we performed. The code for these\ntasks now looked like this:</li>\n</ul>\n<p>{% highlight js %}\nplease(parent).get('window.location').then(function(location) {\n// use location here\n});</p>\n<p>  please(parent).set('foo', 'bar').then(function () {\n// do something here\n});</p>\n<p>  // reload the child window.\nvar childWindow = $('iframe#child').get(0).contentWindow;\nplease(childWindow).call('window.location.reload');\n{% endhighlight %}</p>\n<p>A paradigm shift, yet the logic remained unaffected. Exactly what we wanted.</p>\n<ul>\n<li>The last task was a big one. We had a lot of code in the parent frame\ndirectly accessing the child frame's DOM. While this is not advocated as a good\npractice, such problems are often faced when building upon and improving legacy\ncode. With PostMessage, you can no longer access the child's DOM in any way.\nBut we came up with a smart solution. We know that jQuery is a wrapper around\nthe traditional DOM. We created a PostMessage wrapper around jQuery itself!\nWhich makes impossible turn possible:</li>\n</ul>\n<p>{% highlight js %}\n// set #bar's height in child = foo's height in child\nvar pls = please($('iframe#child').get(0).contentWindow);\npls.$('div#foo').height().then(function (fooHeight) {\npls.$('div#bar').height(fooHeight);\n});</p>\n<p>  // DOM elements are returned back as please.UnserializableObject\n// which can then be passed back to please.$ to do more stuff\npls.$('<div>hello world</div>').then(function (newDiv) {\npls.$(newDiv).appendTo('body');\n});\n{% endhighlight %}</p>\n<p>This was something that I thought of during one of the <a href=\"http://team.wingify.com/friday-engineering-talks-at-wingify\">hackathons</a>\nwe host at Wingify. Turned out to be very fruitful!</p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>In my personal opinion, I believe using promises for such a large transition\nhas greatly impacted the way I think about frontend web development. It is a\nway forward for rapid asynchronous development, and yet having a flattened\nsynchronous-like code structure.</p>\n<p><code class=\"language-text\">please.js</code> will be opensourced soon, so keep an eye out on the blog for updates!</p>","timeToRead":5,"excerpt":"Visual Website Optimizer's editor component loads a website for editing using a\nproxy tunnel. It put a big restriction on what kind ofâ€¦","frontmatter":{"title":"jQuery Promises: The answer to PostMessage's asynchrony","author":"Himanshu Kapoor","authorslug":"himanshu_kapoor"},"fields":{"slug":"/posts/jquery-promises-with-postmessage/","date":"June 16, 2013"}}},"pageContext":{"slug":"/posts/jquery-promises-with-postmessage/","date":"2013-06-16T18:30:00.000Z","nexttitle":"Introduction: Engineering @ Wingify","nextslug":"/posts/introduction/","prevtitle":"How We Made The Animated A/B Testing Guide","prevslug":"/posts/making-of-abtesting-scrollmation/"}}}